(function() {
  var RuntimeProtocol, noflo, portsPayload, sendToInport;

  noflo = require('noflo');

  sendToInport = function(component, portName, event, payload) {
    var port, socket;
    socket = noflo.internalSocket.createSocket();
    port = component.inPorts[portName];
    port.attach(socket);
    switch (event) {
      case 'connect':
        socket.connect();
        break;
      case 'disconnect':
        socket.disconnect();
        break;
      case 'begingroup':
        socket.beginGroup(payload);
        break;
      case 'endgroup':
        socket.endGroup(payload);
        break;
      case 'data':
        socket.send(payload);
    }
    return port.detach(socket);
  };

  portsPayload = function(name, graph) {
    var inports, internal, outports, payload, pub, _ref, _ref1, _ref2, _ref3;
    inports = [];
    outports = [];
    if (graph) {
      _ref = graph.inports;
      for (pub in _ref) {
        internal = _ref[pub];
        inports.push({
          id: pub,
          type: 'any',
          description: (_ref1 = internal.metadata) != null ? _ref1.description : void 0,
          addressable: false,
          required: false
        });
      }
      _ref2 = graph.outports;
      for (pub in _ref2) {
        internal = _ref2[pub];
        outports.push({
          id: pub,
          type: 'any',
          description: (_ref3 = internal.metadata) != null ? _ref3.description : void 0,
          addressable: false,
          required: false
        });
      }
    }
    return payload = {
      graph: name,
      inPorts: inports,
      outPorts: outports
    };
  };

  RuntimeProtocol = (function() {
    function RuntimeProtocol(transport) {
      this.transport = transport;
      this.outputSockets = {};
      this.mainGraph = null;
      this.transport.network.on('addnetwork', (function(_this) {
        return function(network, name) {
          _this.subscribeExportedPorts(name, network.graph, true);
          _this.subscribeOutPorts(name, network);
          _this.sendPorts(name, network.graph);
          network.on('start', function() {
            return _this.subscribeOutdata(name, network, true);
          });
          return network.on('data', function(event) {});
        };
      })(this));
      this.transport.network.on('removenetwork', (function(_this) {
        return function(network, name) {
          _this.subscribeOutdata(name, network, false);
          _this.subscribeOutPorts(name, network);
          _this.subscribeExportedPorts(name, network.graph, false);
          return _this.sendPorts(name, null);
        };
      })(this));
    }

    RuntimeProtocol.prototype.send = function(topic, payload, context) {
      return this.transport.send('runtime', topic, payload, context);
    };

    RuntimeProtocol.prototype.sendAll = function(topic, payload) {
      return this.transport.sendAll('runtime', topic, payload);
    };

    RuntimeProtocol.prototype.sendError = function(message, context) {
      return this.send('error', new Error(message), context);
    };

    RuntimeProtocol.prototype.receive = function(topic, payload, context) {
      if (topic === 'packet' && !this.transport.canDo('protocol:runtime', payload.secret)) {
        this.send('error', new Error("" + topic + " not permitted"), context);
        return;
      }
      switch (topic) {
        case 'getruntime':
          return this.getRuntime(payload, context);
        case 'packet':
          return this.receivePacket(payload, context);
      }
    };

    RuntimeProtocol.prototype.getRuntime = function(payload, context) {
      var capabilities, name, network, permittedCapabilities, type, _ref, _results;
      type = this.transport.options.type;
      if (!type) {
        if (noflo.isBrowser()) {
          type = 'noflo-browser';
        } else {
          type = 'noflo-nodejs';
        }
      }
      capabilities = this.transport.options.capabilities;
      if (!capabilities) {
        capabilities = ['protocol:graph', 'protocol:component', 'protocol:network', 'protocol:runtime', 'component:setsource', 'component:getsource'];
      }
      permittedCapabilities = capabilities.filter((function(_this) {
        return function(capability) {
          return _this.transport.canDo(capability, payload.secret);
        };
      })(this));
      payload = {
        type: type,
        version: this.transport.version,
        capabilities: permittedCapabilities,
        allCapabilities: capabilities
      };
      if (this.mainGraph) {
        payload.graph = this.mainGraph;
      }
      this.send('runtime', payload, context);
      _ref = this.transport.network.networks;
      _results = [];
      for (name in _ref) {
        network = _ref[name];
        _results.push(this.sendPorts(name, network.graph, context));
      }
      return _results;
    };

    RuntimeProtocol.prototype.sendPorts = function(name, graph, context) {
      var payload;
      payload = portsPayload(name, graph);
      if (!context) {
        return this.sendAll('ports', payload);
      } else {
        return this.send('ports', payload, context);
      }
    };

    RuntimeProtocol.prototype.setMainGraph = function(id) {
      return this.mainGraph = id;
    };

    RuntimeProtocol.prototype.subscribeExportedPorts = function(name, graph, add) {
      var d, dependencies, sendExportedPorts, _i, _j, _len, _len1, _results;
      sendExportedPorts = (function(_this) {
        return function() {
          return _this.sendPorts(name, graph);
        };
      })(this);
      dependencies = ['addInport', 'addOutport', 'removeInport', 'removeOutport'];
      for (_i = 0, _len = dependencies.length; _i < _len; _i++) {
        d = dependencies[_i];
        graph.removeListener(d, sendExportedPorts);
      }
      if (add) {
        _results = [];
        for (_j = 0, _len1 = dependencies.length; _j < _len1; _j++) {
          d = dependencies[_j];
          _results.push(graph.on(d, sendExportedPorts));
        }
        return _results;
      }
    };

    RuntimeProtocol.prototype.subscribeOutPorts = function(name, network, add) {
      var graph, portAdded, portRemoved;
      portRemoved = (function(_this) {
        return function() {
          return _this.subscribeOutdata(name, network, false);
        };
      })(this);
      portAdded = (function(_this) {
        return function() {
          return _this.subscribeOutdata(name, network, true);
        };
      })(this);
      graph = network.graph;
      graph.removeListener('addOutport', portAdded);
      graph.removeListener('removeOutport', portRemoved);
      if (add) {
        graph.on('addOutport', portAdded);
        return graph.on('removeOutport', portRemoved);
      }
    };

    RuntimeProtocol.prototype.subscribeOutdata = function(graphName, network, add) {
      var component, event, events, graphSockets, internal, pub, sendFunc, socket, _i, _len, _ref, _results;
      events = ['data', 'begingroup', 'endgroup', 'connect', 'disconnect'];
      if (!this.outputSockets[graphName]) {
        this.outputSockets[graphName] = {};
      }
      graphSockets = this.outputSockets[graphName];
      for (pub in graphSockets) {
        socket = graphSockets[pub];
        for (_i = 0, _len = events.length; _i < _len; _i++) {
          event = events[_i];
          socket.removeAllListeners(event);
        }
      }
      graphSockets = {};
      if (!add) {
        return;
      }
      _ref = network.graph.outports;
      _results = [];
      for (pub in _ref) {
        internal = _ref[pub];
        socket = noflo.internalSocket.createSocket();
        graphSockets[pub] = socket;
        component = network.processes[internal.process].component;
        component.outPorts[internal.port].attach(socket);
        sendFunc = (function(_this) {
          return function(event) {
            return function(payload) {
              return _this.sendAll('packet', {
                port: pub,
                event: event,
                graph: graphName,
                payload: payload
              });
            };
          };
        })(this);
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (_j = 0, _len1 = events.length; _j < _len1; _j++) {
            event = events[_j];
            _results1.push(socket.on(event, sendFunc(event)));
          }
          return _results1;
        })());
      }
      return _results;
    };

    RuntimeProtocol.prototype.receivePacket = function(payload, context) {
      var component, graph, internal, network, _ref;
      graph = this.transport.graph.graphs[payload.graph];
      network = this.transport.network.networks[payload.graph];
      if (!network) {
        return this.sendError("Cannot find network for graph " + payload.graph, context);
      }
      internal = graph.inports[payload.port];
      component = (_ref = network.network.getNode(internal != null ? internal.process : void 0)) != null ? _ref.component : void 0;
      if (!(internal && component)) {
        return this.sendError("Cannot find internal port for " + payload.port, context);
      }
      return sendToInport(component, internal.port, payload.event, payload.payload);
    };

    return RuntimeProtocol;

  })();

  module.exports = RuntimeProtocol;

}).call(this);
